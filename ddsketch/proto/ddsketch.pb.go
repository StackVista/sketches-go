// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ddsketch.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IndexMapping_Interpolation int32

const (
	IndexMapping_NONE      IndexMapping_Interpolation = 0
	IndexMapping_LINEAR    IndexMapping_Interpolation = 1
	IndexMapping_QUADRATIC IndexMapping_Interpolation = 2
	IndexMapping_CUBIC     IndexMapping_Interpolation = 3
)

var IndexMapping_Interpolation_name = map[int32]string{
	0: "NONE",
	1: "LINEAR",
	2: "QUADRATIC",
	3: "CUBIC",
}

var IndexMapping_Interpolation_value = map[string]int32{
	"NONE":      0,
	"LINEAR":    1,
	"QUADRATIC": 2,
	"CUBIC":     3,
}

func (x IndexMapping_Interpolation) String() string {
	return proto.EnumName(IndexMapping_Interpolation_name, int32(x))
}

func (IndexMapping_Interpolation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{1, 0}
}

// A DDSketch is essentially a histogram that partitions the range of positive values into an infinite number of
// indexed bins whose size grows exponentially. It keeps track of the number of values (or possibly floating-point
// weights) added to each bin. Negative values are partitioned like positive values, symmetrically to zero.
// The value zero as well as its close neighborhood that would be mapped to extreme bin indexes is mapped to a specific
// counter.
type DDSketch struct {
	// The mapping between positive values and the bin indexes they belong to.
	Mapping *IndexMapping `protobuf:"bytes,1,opt,name=mapping,proto3" json:"mapping,omitempty"`
	// The store for keeping track of positive values.
	PositiveValues *Store `protobuf:"bytes,2,opt,name=positiveValues,proto3" json:"positiveValues,omitempty"`
	// The store for keeping track of negative values. A negative value v is mapped using its positive opposite -v.
	NegativeValues *Store `protobuf:"bytes,3,opt,name=negativeValues,proto3" json:"negativeValues,omitempty"`
	// The count for the value zero and its close neighborhood (whose width depends on the mapping).
	ZeroCount float64 `protobuf:"fixed64,4,opt,name=zeroCount,proto3" json:"zeroCount,omitempty"`
}

func (m *DDSketch) Reset()         { *m = DDSketch{} }
func (m *DDSketch) String() string { return proto.CompactTextString(m) }
func (*DDSketch) ProtoMessage()    {}
func (*DDSketch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{0}
}
func (m *DDSketch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDSketch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDSketch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DDSketch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDSketch.Merge(m, src)
}
func (m *DDSketch) XXX_Size() int {
	return m.Size()
}
func (m *DDSketch) XXX_DiscardUnknown() {
	xxx_messageInfo_DDSketch.DiscardUnknown(m)
}

var xxx_messageInfo_DDSketch proto.InternalMessageInfo

func (m *DDSketch) GetMapping() *IndexMapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *DDSketch) GetPositiveValues() *Store {
	if m != nil {
		return m.PositiveValues
	}
	return nil
}

func (m *DDSketch) GetNegativeValues() *Store {
	if m != nil {
		return m.NegativeValues
	}
	return nil
}

func (m *DDSketch) GetZeroCount() float64 {
	if m != nil {
		return m.ZeroCount
	}
	return 0
}

// How to map positive values to the bins they belong to.
type IndexMapping struct {
	// The gamma parameter of the mapping, such that bin index that a value v belongs to is roughly equal to
	// log(v)/log(gamma).
	Gamma float64 `protobuf:"fixed64,1,opt,name=gamma,proto3" json:"gamma,omitempty"`
	// An offset that can be used to shift all bin indexes.
	IndexOffset float64 `protobuf:"fixed64,2,opt,name=indexOffset,proto3" json:"indexOffset,omitempty"`
	// To speed up the computation of the index a value belongs to, the computation of the log may be approximated using
	// the fact that the log to the base 2 of powers of 2 can be computed at a low cost from the binary representation of
	// the input value. Other values can be approximated by interpolating between successive powers of 2 (linearly,
	// quadratically or cubically).
	// NONE means that the log is to be computed exactly (no interpolation).
	Interpolation IndexMapping_Interpolation `protobuf:"varint,3,opt,name=interpolation,proto3,enum=IndexMapping_Interpolation" json:"interpolation,omitempty"`
}

func (m *IndexMapping) Reset()         { *m = IndexMapping{} }
func (m *IndexMapping) String() string { return proto.CompactTextString(m) }
func (*IndexMapping) ProtoMessage()    {}
func (*IndexMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{1}
}
func (m *IndexMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexMapping.Merge(m, src)
}
func (m *IndexMapping) XXX_Size() int {
	return m.Size()
}
func (m *IndexMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexMapping.DiscardUnknown(m)
}

var xxx_messageInfo_IndexMapping proto.InternalMessageInfo

func (m *IndexMapping) GetGamma() float64 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

func (m *IndexMapping) GetIndexOffset() float64 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *IndexMapping) GetInterpolation() IndexMapping_Interpolation {
	if m != nil {
		return m.Interpolation
	}
	return IndexMapping_NONE
}

// A Store maps bin indexes to their respective counts.
// Counts can be encoded sparsely using binCounts, but also in a contiguous way using contiguousBinCounts and
// contiguousBinIndexOffset. Given that non-empty bins are in practice usually contiguous or close to one another, the
// latter contiguous encoding method is usually more efficient than the sparse one.
// Both encoding methods can be used conjointly. If a bin appears in both the sparse and the contiguous encodings, its
// count value is the sum of the counts in each encodings.
type Store struct {
	// The bin counts, encoded sparsely.
	BinCounts map[int32]float64 `protobuf:"bytes,1,rep,name=binCounts,proto3" json:"binCounts,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// The bin counts, encoded contiguously. The values of contiguousBinCounts are the counts for the bins of indexes
	// o, o+1, o+2, etc., where o is contiguousBinIndexOffset.
	ContiguousBinCounts      []float64 `protobuf:"fixed64,2,rep,packed,name=contiguousBinCounts,proto3" json:"contiguousBinCounts,omitempty"`
	ContiguousBinIndexOffset int32     `protobuf:"zigzag32,3,opt,name=contiguousBinIndexOffset,proto3" json:"contiguousBinIndexOffset,omitempty"`
}

func (m *Store) Reset()         { *m = Store{} }
func (m *Store) String() string { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()    {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{2}
}
func (m *Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return m.Size()
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetBinCounts() map[int32]float64 {
	if m != nil {
		return m.BinCounts
	}
	return nil
}

func (m *Store) GetContiguousBinCounts() []float64 {
	if m != nil {
		return m.ContiguousBinCounts
	}
	return nil
}

func (m *Store) GetContiguousBinIndexOffset() int32 {
	if m != nil {
		return m.ContiguousBinIndexOffset
	}
	return 0
}

func init() {
	proto.RegisterEnum("IndexMapping_Interpolation", IndexMapping_Interpolation_name, IndexMapping_Interpolation_value)
	proto.RegisterType((*DDSketch)(nil), "DDSketch")
	proto.RegisterType((*IndexMapping)(nil), "IndexMapping")
	proto.RegisterType((*Store)(nil), "Store")
	proto.RegisterMapType((map[int32]float64)(nil), "Store.BinCountsEntry")
}

func init() { proto.RegisterFile("ddsketch.proto", fileDescriptor_bc8a52eb53c27981) }

var fileDescriptor_bc8a52eb53c27981 = []byte{
	// 447 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0x73, 0xed, 0x26, 0x34, 0x37, 0x24, 0x72, 0x07, 0x90, 0x2c, 0x40, 0x96, 0x95, 0x0d,
	0xd9, 0xe0, 0xa0, 0x94, 0x05, 0xaa, 0x90, 0x50, 0xfe, 0x16, 0x46, 0x90, 0x8a, 0x09, 0xed, 0x82,
	0x9d, 0x93, 0x4c, 0xdd, 0x51, 0xea, 0x19, 0xcb, 0x1e, 0x57, 0x94, 0xa7, 0xe0, 0x55, 0x78, 0x0b,
	0xc4, 0xaa, 0x4b, 0x96, 0x28, 0xd9, 0xf2, 0x10, 0xc8, 0x63, 0x42, 0x6c, 0x04, 0x2b, 0x7b, 0xce,
	0xf9, 0x46, 0x3a, 0x73, 0xee, 0xc5, 0xce, 0x6a, 0x95, 0xae, 0x99, 0x5a, 0x5e, 0x7a, 0x71, 0x22,
	0x95, 0xec, 0x7e, 0x01, 0x3c, 0x9c, 0x4c, 0xe6, 0x5a, 0x22, 0x4f, 0xf0, 0x4e, 0x14, 0xc4, 0x31,
	0x17, 0xa1, 0x0d, 0x2e, 0xf4, 0x5a, 0x83, 0xb6, 0xe7, 0x8b, 0x15, 0xfb, 0xf8, 0xb6, 0x10, 0xe9,
	0xce, 0x25, 0x1e, 0x76, 0x62, 0x99, 0x72, 0xc5, 0xaf, 0xd9, 0x79, 0x70, 0x95, 0xb1, 0xd4, 0x36,
	0x34, 0xdf, 0xf0, 0xe6, 0x4a, 0x26, 0x8c, 0xfe, 0xe5, 0xe6, 0xbc, 0x60, 0x61, 0x50, 0xe2, 0xcd,
	0x2a, 0x5f, 0x75, 0xc9, 0x63, 0x6c, 0x7e, 0x62, 0x89, 0x1c, 0xcb, 0x4c, 0x28, 0xfb, 0xc0, 0x85,
	0x1e, 0xd0, 0xbd, 0xd0, 0xfd, 0x06, 0x78, 0xb7, 0x9c, 0x8b, 0xdc, 0xc7, 0x7a, 0x18, 0x44, 0x51,
	0xa0, 0x53, 0x03, 0x2d, 0x0e, 0xc4, 0xc5, 0x16, 0xcf, 0xa9, 0xd3, 0x8b, 0x8b, 0x94, 0x29, 0x9d,
	0x10, 0x68, 0x59, 0x22, 0x43, 0x6c, 0x73, 0xa1, 0x58, 0x12, 0xcb, 0xab, 0x40, 0x71, 0x29, 0x74,
	0xaa, 0xce, 0xe0, 0x51, 0xe5, 0xd5, 0x9e, 0x5f, 0x46, 0x68, 0xf5, 0x46, 0xf7, 0x15, 0xb6, 0x2b,
	0x3e, 0x39, 0xc4, 0x83, 0xd9, 0xe9, 0x6c, 0x6a, 0xd5, 0x08, 0x62, 0xe3, 0x8d, 0x3f, 0x9b, 0x0e,
	0xa9, 0x05, 0xa4, 0x8d, 0xcd, 0x77, 0x67, 0xc3, 0x09, 0x1d, 0xbe, 0xf7, 0xc7, 0x96, 0x41, 0x9a,
	0x58, 0x1f, 0x9f, 0x8d, 0xfc, 0xb1, 0x65, 0x76, 0x7f, 0x02, 0xd6, 0x75, 0x09, 0xe4, 0x18, 0x9b,
	0x0b, 0x2e, 0xf4, 0x13, 0x53, 0x1b, 0x5c, 0xb3, 0xd7, 0x1a, 0x3c, 0x28, 0xfa, 0xf1, 0x46, 0x3b,
	0x7d, 0x2a, 0x54, 0x72, 0x43, 0xf7, 0x1c, 0x79, 0x8e, 0xf7, 0x96, 0x52, 0x28, 0x1e, 0x66, 0x32,
	0x4b, 0xff, 0x60, 0xb6, 0xe1, 0x9a, 0x3d, 0x18, 0x19, 0x16, 0xd0, 0x7f, 0xd9, 0xe4, 0x04, 0xed,
	0x8a, 0xec, 0x97, 0x7a, 0xca, 0x3b, 0x38, 0xa2, 0xff, 0xf5, 0x1f, 0xbe, 0xc4, 0x4e, 0x35, 0x0e,
	0xb1, 0xd0, 0x5c, 0xb3, 0x1b, 0x5d, 0xfe, 0x11, 0xcd, 0x7f, 0xf3, 0x81, 0x5c, 0xe7, 0x93, 0xfc,
	0x5d, 0x7a, 0x71, 0x38, 0x31, 0x5e, 0xc0, 0xe8, 0xf5, 0xd7, 0x8d, 0x03, 0xb7, 0x1b, 0x07, 0x7e,
	0x6c, 0x1c, 0xf8, 0xbc, 0x75, 0x6a, 0xb7, 0x5b, 0xa7, 0xf6, 0x7d, 0xeb, 0xd4, 0x3e, 0x3c, 0x0b,
	0xb9, 0xba, 0xcc, 0x16, 0xde, 0x52, 0x46, 0xfd, 0xb9, 0x0a, 0x96, 0xeb, 0x73, 0x9e, 0xaa, 0xa0,
	0x5f, 0x6c, 0x2b, 0x4b, 0x9f, 0x86, 0xb2, 0xbf, 0xdb, 0xdd, 0xbe, 0xde, 0xdd, 0x45, 0x43, 0x7f,
	0x8e, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x87, 0x8d, 0x11, 0x36, 0xd4, 0x02, 0x00, 0x00,
}

func (m *DDSketch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDSketch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DDSketch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ZeroCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ZeroCount))))
		i--
		dAtA[i] = 0x21
	}
	if m.NegativeValues != nil {
		{
			size, err := m.NegativeValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdsketch(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PositiveValues != nil {
		{
			size, err := m.PositiveValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdsketch(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Mapping != nil {
		{
			size, err := m.Mapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdsketch(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Interpolation != 0 {
		i = encodeVarintDdsketch(dAtA, i, uint64(m.Interpolation))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexOffset != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.IndexOffset))))
		i--
		dAtA[i] = 0x11
	}
	if m.Gamma != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gamma))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Store) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Store) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Store) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContiguousBinIndexOffset != 0 {
		i = encodeVarintDdsketch(dAtA, i, uint64((uint32(m.ContiguousBinIndexOffset)<<1)^uint32((m.ContiguousBinIndexOffset>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContiguousBinCounts) > 0 {
		for iNdEx := len(m.ContiguousBinCounts) - 1; iNdEx >= 0; iNdEx-- {
			f4 := math.Float64bits(float64(m.ContiguousBinCounts[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f4))
		}
		i = encodeVarintDdsketch(dAtA, i, uint64(len(m.ContiguousBinCounts)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BinCounts) > 0 {
		for k := range m.BinCounts {
			v := m.BinCounts[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarintDdsketch(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDdsketch(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDdsketch(dAtA []byte, offset int, v uint64) int {
	offset -= sovDdsketch(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DDSketch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mapping != nil {
		l = m.Mapping.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.PositiveValues != nil {
		l = m.PositiveValues.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.NegativeValues != nil {
		l = m.NegativeValues.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.ZeroCount != 0 {
		n += 9
	}
	return n
}

func (m *IndexMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gamma != 0 {
		n += 9
	}
	if m.IndexOffset != 0 {
		n += 9
	}
	if m.Interpolation != 0 {
		n += 1 + sovDdsketch(uint64(m.Interpolation))
	}
	return n
}

func (m *Store) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BinCounts) > 0 {
		for k, v := range m.BinCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sozDdsketch(uint64(k)) + 1 + 8
			n += mapEntrySize + 1 + sovDdsketch(uint64(mapEntrySize))
		}
	}
	if len(m.ContiguousBinCounts) > 0 {
		n += 1 + sovDdsketch(uint64(len(m.ContiguousBinCounts)*8)) + len(m.ContiguousBinCounts)*8
	}
	if m.ContiguousBinIndexOffset != 0 {
		n += 1 + sozDdsketch(uint64(m.ContiguousBinIndexOffset))
	}
	return n
}

func sovDdsketch(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDdsketch(x uint64) (n int) {
	return sovDdsketch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DDSketch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDSketch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDSketch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdsketch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mapping == nil {
				m.Mapping = &IndexMapping{}
			}
			if err := m.Mapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdsketch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositiveValues == nil {
				m.PositiveValues = &Store{}
			}
			if err := m.PositiveValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdsketch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NegativeValues == nil {
				m.NegativeValues = &Store{}
			}
			if err := m.NegativeValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ZeroCount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gamma = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexOffset", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.IndexOffset = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interpolation", wireType)
			}
			m.Interpolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interpolation |= IndexMapping_Interpolation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdsketch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinCounts == nil {
				m.BinCounts = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdsketch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDdsketch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDdsketch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDdsketch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BinCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ContiguousBinCounts = append(m.ContiguousBinCounts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdsketch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDdsketch
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDdsketch
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ContiguousBinCounts) == 0 {
					m.ContiguousBinCounts = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ContiguousBinCounts = append(m.ContiguousBinCounts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ContiguousBinCounts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContiguousBinIndexOffset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ContiguousBinIndexOffset = v
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDdsketch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDdsketch
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDdsketch
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDdsketch
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDdsketch        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDdsketch          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDdsketch = fmt.Errorf("proto: unexpected end of group")
)
